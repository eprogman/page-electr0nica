[
    {
        "tema": "Parpadeo de LED mediante el uso del TIMER 1 del PIC18F57Q43",
        "descripcion": "Se configuró un programa para el PIC18F57Q43, para el encendido y apagado de un LED, y posteriormente se observó la señal con un osciloscopio, y verificó el tiempo en alto y tiempo en bajo de la señal, y cada cual corresponde a un salto de interrupción generada en el PIC.",
        "imagen1": "/images/led.jpeg",
        "imagen2": "/images/onda.jpeg",
        "datos": "Cabe mencionar que en datasheet indica que el módulo Timer1 es un contador de 16 bits que incrementa y se accede a través del registro TMRx y Cuando se utiliza con una fuente de reloj interna, el módulo funciona como un temporizador que incrementa en cada ciclo de instrucción. El registro TMRx incrementa hasta FFFFh y se reinicia a 0000h. Cuando TMRx se reinicia, se establece el bit de la bandera de interrupción de Timer1 del registro PIRx.",
        "implementación": "Se utiliza dos funciones, la función void __interrupt(irq(IRQ_TMR1)) TMR1_ISR(void) y dentro un if(PIR3bits.TMR1IF) que es la bandera de instrucción para la ejecución del cambio de estado de LED, seguidamente también limpiar la bandera. La otra función es el void main(void), función principal, donde se configurará el registro TRISF y LATF para establecer RF3 como salida, así mismo en el uso del Timer1 se adapta para funcionar con Fosc/4 y Prescaler 1:4, configurando T1CLK=0x01 y T1CON=0x23. Con respecto a las interrupciones, se habilita la interrupción con Alta y Baja prioridad con IPEN, por consiguiente alta y baja prioridad con GIEH y GIEL, adicionalmente se limpia la bandera, se habilita interrupción Timer1 y la prioridad alta del Timer1, usando TMR1IF,TMR1IE,TMR1IP respectivamente. Usando un Oscilador interno de 4Mhz salta a interrupción cada 260ms para cambiar el estado de LED."
    },
    {
        "tema": "Uso de display OLED I2C",
        "descripcion": "Para este proyecto se realizó un programa para PIC18F4550 con el uso del modo I2C del PIC, para mostrar el texto 'Hola Mundo' en el displey OLED, como también se programó el PIC para mostrar un número escrito en le memoria no volatil EEPROM del PIC, para después ser leído y seguidamente guardado en un 'unsigned char valor', para juntamente con el 'Hola mundo' mostrarlo también por el display OLED",
        "imagen1": "/images/oled.jpeg",
        "datos": "En datasheet del PIC se indica se utilizan dos pines para la transferencia de datos: Serial clock (SCL) - RB1 y Serial data (SDA) - RB0.  También indica que el usuario debe configurar estos pines como entradas estableciendo los bits TRIS asociados. La EEPROM de datos es una matriz de memoria no volátil, separada de la RAM de datos y de la memoria de programa, que se utiliza para el almacenamiento a largo plazo de datos de programa. No está directamente mapeada ni en el archivo de registros ni en el espacio de memoria de programa, pero se accede de manera indirecta a través de los Registros de Función Especial (SFRs). La EEPROM se puede leer y escribir durante la operación normal en todo el rango de VDD. Se utilizan cuatro SFRs para leer y escribir en la EEPROM de datos, así como en la memoria de programa. Estos son: • EECON1 • EECON2 • EEDATA • EEADR",
        "implementación": "A través de un pequeño protoboard, se armó un circuito con el PIC y el OLED, y un crystal de 4Mhz , con respecto al programa se utilizó 4 funciones, void escribirEEPROM(unsigned char direccion, unsigned char dato), unsigned char leerEEPROM(unsigned char direccion), void MostrarDatosOLED(void) y void main(void), sobre la primera se manda la dirección del EEPROM y el dato '250', con respecto a la segunda es para leer el dato de la EEPROM, la tercera función es para escribir en el display OLED, el número previamente guardado y la ultima es para inicializar el I2C y OLED'."
    },
    {
        "tema": "Apagado y Encendido automático de un equipo ROUTER o SWITCH",
        "descripcion": "Para este proyecto se realizó la programación e implementación para lograr el apagado y encendido automático de un equipo eletrónico tipo router o un switch, utilizando un PIC16F877A y un módulo Reloj RTC DS1307, un display LCD 16X2 y un teclado matricial 4x4.",
        "imagen1": "/images/alarma1.jpeg",
        "imagen2": "/images/alarma2.jpeg",
        "imagen3": "/images/alarma3.jpeg",
        "imagen4": "/images/alarma4.jpeg",
        "datos": "Se observa en datasheet del PIC, se utilizan dos pines para la transferencia de datos: Serial clock (SCL)-RC3 y Serial data (SDA)-RC4. SSPCON, SSPCON2 y SSPSTAT son los registros de control y estado en la operación en modo I2C. En el modo Transmisor Maestro, los datos en serie se envían a través de SDA mientras SCL proporciona el reloj en serie. Una secuencia de transmisión típica sería la siguiente: 1. El usuario genera una condición de inicio configurando el bit de Habilitar Inicio, SEN (SSPCON2<0>). 2. Se establece SSPIF. El módulo MSSP esperará el tiempo de inicio requerido antes de que tenga lugar cualquier otra operación. 3. El usuario carga el SSPBUF con la dirección del esclavo para transmitir. 4. La dirección se desplaza por el pin SDA hasta que se transmiten los 8 bits. 5. El módulo MSSP recibe el bit ACK del dispositivo esclavo y escribe su valor en el registro SSPCON2 (SSPCON2<6>). 6. El módulo MSSP genera una interrupción al final del noveno ciclo de reloj configurando el bit SSPIF. 7. El usuario carga el SSPBUF con ocho bits de datos. 8. Los datos se desplazan por el pin SDA hasta que se transmiten los 8 bits. 9. El módulo MSSP recibe el bit ACK del dispositivo esclavo y escribe su valor en el registro SSPCON2 (SSPCON2<6>). 10. El módulo MSSP genera una interrupción al final del noveno ciclo de reloj configurando el bit SSPIF. 11. El usuario genera una condición de parada configurando el bit de Habilitar Parada, PEN (SSPCON2<2>). 12. Se genera una interrupción una vez que la condición de parada se completa.",
        "implementación": "Para este proyecto con componentes electrónicos de fácil adquisición en el mercado, se realizó el diseño en circuito impreso para luego ser implementado y probado para el encendido y apagado de forma automática de un equipo router o switch que esta conectado a la corriente eléctrica, el cual se requiere que se apague a una hora nocturna deseada y configurable para posteriormente se encienda a la hora también elegida en horas de la mañana la cual tambien es configurable. En la programación del PIC se programó 4 funciones, la primera para mostrar los datos a través del LCD, la segunda para obtener y almacenar en un buffer, los dígitos ingresados a través del teclado matricial como también ir mostrándolos por el LCD, la tercera es la función que se llama desde el void main(void) y convierte los dígitos del teclado a formato decimal y se guarda en valores unsigned char, como también escribir valores al módulo RTC, la última es la función void main(void) que habilita los puertos de salida, como también inicializa el modo I2C del PIC, inicializa el LCD 16X2 y el teclado matricial, seguidamente lee los valores del módulo RTC previamente escritos, para ser mostrados en LCD juntos con los demás valores unsigned char, luego tiene una comparación para encendido y apagado de un bit en PORTA'."
    }
]